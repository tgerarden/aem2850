---
title: "Strings and regular expressions"
author: "Todd Gerarden"
output:
  xaringan::moon_reader:
    lib_dir: "libs"
    css: ["xaringan-themer.css", "css/tdg-slides.css"]
#    css: ['default', 'metropolis', 'metropolis-fonts']
    seal: false
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%"
      ratio: "16:9"
      navigation:
        scroll: false
      # beforeInit: "libs/offline-mathjax.js"
editor_options: 
  chunk_output_type: console
---

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_mono_accent(base_color = "#B31B1B",
                  text_font_size = "1.4rem")
xaringanExtra::use_xaringan_extra(c("tile_view"))
```

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(warning = FALSE, message = FALSE, 
                      #cache = TRUE,
                      fig.retina = 3, fig.align = "center",
                      fig.width=14, fig.height=7)
```

```{r packages-data, include=FALSE}
library(tidyverse)

# options("digits" = 2, "width" = 90)
```


class: center, middle

# Strings and regular expressions

.class-info[

**Week 5**

AEM 2850 / 5850 : R for Business Analytics<br>
Cornell Dyson<br>
Spring 2025

Acknowledgements: 
<!-- [Andrew Heiss](https://datavizm20.classes.andrewheiss.com), -->
<!-- [Claus Wilke](https://wilkelab.org/SDS375/),  -->
<!-- [Grant McDermott](https://github.com/uo-ec607/lectures), -->
<!-- [Jenny Bryan](https://stat545.com/join-cheatsheet.html), -->
<!-- [Allison Horst](https://github.com/allisonhorst/stats-illustrations) -->
[R4DS (2e)](https://r4ds.hadley.nz)

]

---

# Announcements

No lab due next Monday (February break)

Prelim 1 will be next Thursday, February 29 in class
  - Will cover everything so far **including this week's material**
  - We will provide more guidance Thursday and via canvas
  - Please contact me and SDS **as soon as possible** if you are eligible for testing accommodations and are not yet registered

Questions before we get started?


---

# Plan for today

[Prologue: clarifying group operations](#prologue)

[Working with strings in R](#working-with-strings)

[Regular expressions](#regex)

[Working with regular expressions in R](#working-with-regex)


---
class: inverse, center, middle
name: prologue

# Prologue

---

# Group operations

Lab-04 included the following question:

> **3. Calculate the average housing price for each of the cities that are in `tidy_txhouse` and in `tidy_txpop` over the period 2010 through 2012. Which city has the highest average housing price? Which city has the lowest average housing price?**

--

This is a good example question to provide more detail on `group_by()` and `ungroup()`, which I mentioned in passing during week 2

```{r, echo=FALSE}
tidy_txhouse <- read_csv("data/05-slides/tidy_txhouse.csv", show_col_types = FALSE)
tx_pop_city <- read_csv("data/05-slides/tidy_txpop.csv", show_col_types = FALSE) |> 
  distinct(city)
```

---

# Reminder: dplyr::group_by

`summarize` is particularly useful in combination with `group_by`:

```{r}
semi_join(tidy_txhouse, tx_pop_city) |>   # for cities in tidy_txhouse and tx_pop_city
  filter(2010 <= year & year <= 2012) |>  # for years 2010-2012
  group_by(city) |>                       # for each city #<< 
  summarize(mean_price = mean(price))     # compute the mean price #<<
```

---

# Groups are persistent (sort of)

.pull-left[
```{r, highlight.output = c(2, 5, 6, 7)}
semi_join(tidy_txhouse, tx_pop_city) |>
  filter(2010 <= year & year <= 2012) |>
  group_by(city) |> 
  print(n = 5)
```
]

--

.pull-right[
```{r, highlight.output = 4}
semi_join(tidy_txhouse, tx_pop_city) |>
  filter(2010 <= year & year <= 2012) |>
  group_by(city) |> 
  summarize(mean_price = mean(price)) |> 
  print(n = 5)
```
No groups?!
]

---

# Groups are persistent (sort of)

.pull-left[
`summarize()` drops the last group variable, so the output is not grouped by `city`

By contrast `mutate()` does not unroll group variables unless you explicitly ask it to
]

.pull-right[
```{r, highlight.output = c(2, 5, 6, 7)}
semi_join(tidy_txhouse, tx_pop_city) |>
  filter(2010 <= year & year <= 2012) |>
  group_by(city) |> 
  mutate(mean_price = mean(price))
```
]

---

# Groups affect filter operations!

.pull-left[
```{r}
semi_join(tidy_txhouse, tx_pop_city) |>
  filter(2010 <= year & year <= 2012) |>
  group_by(city) |> 
  summarize(mean_price = mean(price)) |> #<<
  filter(mean_price == max(mean_price)) #<<
```

Looks good!
]

--

.pull-right[
```{r, highlight.output = 2}
semi_join(tidy_txhouse, tx_pop_city) |>
  filter(2010 <= year & year <= 2012) |>
  group_by(city) |> 
  mutate(mean_price = mean(price)) |> #<<
  filter(mean_price == max(mean_price)) |>  #<<
  head(5)
```

What went wrong?
]

---

# Groups affect filter operations!

.pull-left[
One way to get around this is to use `ungroup()` or `group_by()` with no arguments

Now we get Austin and only Austin

But we still get multiple rows, when we only need/want one
]

.pull-left[
```{r, highlight.output = 2}
semi_join(tidy_txhouse, tx_pop_city) |>
  filter(2010 <= year & year <= 2012) |>
  group_by(city) |> 
  mutate(mean_price = mean(price)) |> 
  ungroup() |> #<<
  filter(mean_price == max(mean_price)) |> 
  head(5)
```
]


---
class: inverse, center, middle
name: working-with-strings

# Working with strings in R

---

# Strings are nothing new

.pull-left[
```{r eval=FALSE, highlight.output = 3}
flights |>
  select(carrier, tailnum, origin, dest)
```
```{r echo=FALSE, highlight.output = 3}
# two separate code chunks just to focus on what matters (above),
# and avoid confusion about this method to call object flights (below)
nycflights13::flights |> 
  select(carrier, tailnum, origin, dest)
```
]

.pull-right[
```{r highlight.output = 3, include=FALSE}
read_csv("data/our-companies.csv") |> 
  select(name)
```

```{r highlight.output = 3}
tx_pop_city |> 
  select(city)
```

]

---

# Strings in R

Strings are also referred to as "characters" (abbreviated `chr`)

Strings can be stored in many ways:
- Vectors
- **Data frame columns**
- Elements in a list

So far we have used them as we would any other data

--

**But now we'll learn to filter on, modify, or analyze "functions" of strings**

---

# The stringr package

`stringr` is loaded as part of the core tidyverse

All `stringr` functions have intuitive names that start with `str_`

We will cover a bunch of handy functions this week:
1. `str_length`
2. `str_to_upper` and `str_to_lower`
3. `str_c` and `str_glue`
4. `str_detect`
5. `str_count`
6. `str_replace`

See `vignette("stringr")` for more

---

# We'll use data from The Office

The `schrute` package contains transcripts of all episodes of [The Office](https://www.imdb.com/title/tt0386676/) (US)

```{r}
library(schrute)
theoffice # this data frame is an object from the schrute package
```


---

# 1) str_length()

--

`str_length` tells you the number of characters in a string

--

```{r}
str_length("supercalifragilisticexpialidocious")
```

--
```{r}
theoffice |> 
  distinct(character) |> 
  slice_head(n = 5) |> 
  mutate(name_length = str_length(character)) #<<
```

---

# 2) str_to_lower() and str_to_upper()

`str_to_lower` converts to lower case

```{r}
str_to_lower("I went to Cornell, you ever heard of it?")
```

--

`str_to_upper` converts to upper case

```{r}
str_to_upper("I went to Cornell, you ever heard of it?")
```

--

Similar functionality for `str_to_title()` and `str_to_sentence()`

--

These functions are locale dependent (e.g., "en_GB" vs "en_US")


---

# 3) str_c()

--

We have seen `c()` combine arguments into a vector or list

Similarly, `str_c()` combines arguments into a character vector:
```{r}
str_c("a", "b", "c", "1", "2", "3")
```

Here, it combined six letters and numbers into a single string

But we can also use it within data frames to combine strings at scale


---

# 3) str_c()

Here's an example of multiple columns in a data frame being combined into one:

```{r}
theoffice |> slice_head(n = 1) |> 
  select(character, text)
```

```{r, eval=FALSE}
theoffice |> slice_head(n = 1) |> 
    transmute(line = str_c(character, " said: ", text)) # mutate and keep only `line` #<<
```

--

```{r, echo=FALSE}
theoffice |> slice_head(n = 1) |> 
    transmute(line = str_c(character, " said: ", text)) # mutate and keep only `line` #<<
```

---

# 3) str_c()

`str_c()` will automatically recycle fixed arguments like **" said: "** that are shorter than `character` and `text`:

```{r}
theoffice |> slice_head(n = 3) |> 
    transmute(line = str_c(character, " said: ", text))
```

--

`str_c()` and `str_glue()` work well with `mutate()` and `transmute()` because their output is the same length as their inputs

---

# 3) str_glue()

`str_glue()` provides similar functionality, but different syntax:

```{r}
theoffice |> slice_head(n = 3) |> 
    transmute(line = str_glue("{character} said: {text}")) # note the different syntax #<<
```

Items inside `{}` are evaluated as if they are outside the quotes

This can be handy when combining many fixed and variable strings


---
class: inverse, center, middle
name: regex

# Regular expressions

---

# Regular expressions

What are regular expressions?

--

A concise, powerful way for describing patterns within strings

--

Regular expressions are a generic tool, not something specific to R

--

Let's use the names of some characters from The Office as examples:

```{r}
names <- theoffice |> distinct(character) |> slice_head(n = 10) |> pull(character)
names
```

---

# Pattern basics

The simplest patterns consist of literal characters

.pull-left[
```{r, eval=FALSE}
names
```

```{r, echo=FALSE}
print(names, width = 50)
```
]

.pull-right[
What do you think this will return?

```{r, eval=FALSE}
str_view(names, pattern = "J")
```
]

--

.pull-left[
`str_view()` is a handy utility to see how patterns match
]

.pull-right[
```{r, echo=FALSE}
str_view(names, pattern = "J")
```
Literal pattern matches are case-sensitive by default
]


---

# Meta-characters

Punctuation characters like `.`, `+`, `*`, `[`, `]`, and `?` are **meta-characters** with special meanings

The most common one is `.`, which will match any character

--

What do you think these statements will return?

.pull-left[
```{r, eval=FALSE}
str_view(names, pattern = "J.m")
```
]

.pull-right[
```{r, eval=FALSE}
str_view(names, pattern = "J.n")
```
]

--

.pull-left[
```{r, echo=FALSE}
str_view(names, pattern = "J.m")
```
]

--

.pull-right[
```{r, echo=FALSE}
str_view(names, pattern = "J.n")
```
]

---

# Meta-characters

What do you think these statements will return?

.pull-left[
```{r, eval=FALSE}
str_view(names, pattern = "J..")
```
]

.pull-right[
```{r, eval=FALSE}
str_view(names, pattern = "J...")
```
]

--

.pull-left[
```{r, echo=FALSE}
str_view(names, pattern = "J..")
```
]

.pull-right[
```{r, echo=FALSE}
str_view(names, pattern = "J...")
```
]

---

# Quantifiers

Quantifiers control how many times a pattern can match:

- `?` makes a pattern optional -- it matches 0 or 1 times
- `+` lets a pattern repeat -- it matches at least once
- `*` lets a pattern be optional or repeat

--

What do you think this statement will return?

```{r, eval=FALSE}
str_view(names, "M.*l") # match strings with M, then any number of any characters, then l
```

--

```{r, echo=FALSE}
str_view(names, "M.*l") # match strings with M, then any number of any characters, then l
```

---

# Character classes

.pull-left[
`[]` lets you match a set of characters

```{r}
str_view(names, "[aeiou]") # vowels
```
]

--

.pull-right[
`^` inverts character class matches

```{r}
str_view(names, "[^aeiou]") # NOT vowels
```
]

---

# Alternation

Last one! Hang in there!

--

Alternation, `|`, allows you to search for one or more alternative patterns

This should seem familiar...

--

What do you think these statements will return?

.pull-left[
```{r, eval=FALSE}
str_view(names, "J.m|P.m")
```
]

.pull-right[
```{r, eval=FALSE}
str_view(names, "S.*|O.*")
```
]

--

.pull-left[
```{r, echo=FALSE}
str_view(names, "J.m|P.m")
```
]

--

.pull-right[
```{r, echo=FALSE}
str_view(names, "S.*|O.*")
```
]


---

# More patterns

See [Chapter 15 of R4DS (2e)](https://r4ds.hadley.nz/regexps.html#pattern-details) for more on:
- **escaping**: matching meta-characters as if they were literal strings
- **anchors**: match the start or end of a strong
- **character classes** (continued)
- **quantifiers** (continued)
- **operator precedence**: parentheses, etc.
- **grouping**: back references, etc.

---
class: inverse, center, middle
name: working-with-regex

# Working with regular expressions in R

---

# 4) str_detect()

--

`str_detect` can be used to match patterns and return a logical vector

--

.pull-left[
```{r}
first_4_characters <- theoffice |> 
  distinct(character) |> 
  slice_head(n = 4) |> 
  pull(character)
first_4_characters
```
]

--

.pull-right[
```{r}
str_detect(first_4_characters, "Dwight")

str_detect(first_4_characters, "a")
```
]

--

<br>

How could we fit this into our current workflow?

---

# 4) str_detect()

`str_detect` is a powerful way to `filter` a data frame

--

```{r}
theoffice |> select(season, episode, character, text) |> 
  filter(str_detect(text,    # where to match a pattern #<<
                    "sale")) # what pattern to match #<<
```

---

# 4) str_detect()

Literal pattern matches with `str_detect` are case-sensitive

```{r}
theoffice |> select(season, episode, character, text) |> 
  filter(str_detect(text, 
                    "Sale")) # sale and Sale produce different output #<<
```

---

# 4) str_detect()

You could use multiple calls to `str_detect`, or use alternation:

```{r highlight.output = c(6, 10)}
theoffice |> select(season, episode, character, text) |> 
  filter(str_detect(text, 
                    "sale|Sale")) # look for sale OR Sale #<<
```

---

# 4) str_detect()

You could consolidate this: regex parentheses are like in math

```{r}
theoffice |> select(season, episode, character, text) |> 
  filter(str_detect(text, 
                    "(s|S)ale")) # look for sale OR Sale #<<
```

---

# 4) str_detect()

Or use `regex()` to ignore all cases and control other pattern matching details

```{r}
theoffice |> select(season, episode, character, text) |> 
  filter(str_detect(text, 
                    regex("Sale", ignore_case = TRUE))) # ignore case #<<
```


---

# 4) str_detect()

When I say ignore all cases, I mean IGNORE ALL CASES!

```{r}
theoffice |> select(season, episode, character, text) |> 
  filter(str_detect(text, 
                    regex("sale", ignore_case = TRUE))) |>
  filter(!str_detect(text, "(s|S)ale")) # find non-standard form(s) #<<
```

---

# 4) str_detect()

`str_detect` can be combined with familiar functions to summarize data

--

```{r}
theoffice |> 
  filter(str_detect(text, regex("Sale", ignore_case = TRUE))) |> 
  count(character, sort = TRUE) #<<
```

---

# 4) str_detect()

`str_detect` can be combined with familiar functions to summarize data

```{r}
theoffice |> 
  filter(str_detect(text, 
                    regex("that's what she said", ignore_case = TRUE))) |> #<<
  count(character, sort = TRUE)
```

---

# 4) str_detect()

`str_detect` with regular expressions can be very powerful

```{r highlight.output = c(5,6)}
theoffice |> select(character, text) |> 
  filter(str_detect(text, "assistant.*manager")) |> #<<
  slice_head(n = 10)
```

---

# 5) str_count()

`str_count()` can be used to count the number of matches in a string

```{r}
theoffice |> 
  distinct(character) |> 
  slice_head(n = 5) |> 
  mutate(
    name = str_to_lower(character), # another way to avoid case sensitivity
    m_s = str_count(name, "m"), #<<
    i_s = str_count(name, "i") #<<
  )
```

---

# 5) str_count() with regex

```{r}
theoffice |> 
  distinct(character) |> 
  slice_head(n = 5) |> 
  mutate(
    name = str_to_lower(character),
    vowels = str_count(name, "[aeiou]"), # count matches of ANY of these characters #<<
    consonants = str_count(name, "[^aeiou]") # count matches of everything EXCEPT these characters #<<
  )
```

Reminder: `[]` lets you match a set of characters; `^` inverts character class matches

---

# 6) str_replace()

As the name suggests, `str_replace()` can be used to modify patterns in strings

```{r}
names
str_replace(names, "Dw", "Duhw") # jim's office pronunciation guide
```

---

# 6) str_replace()

`str_replace()` replaces the first match of a pattern

`str_replace_all()` replaces all matches of a pattern

These functions pair naturally with `mutate()` just like `str_c()`, `str_glue()`, and `str_count()`

<!-- https://r4ds.hadley.nz/regexps.html#replace-values -->
